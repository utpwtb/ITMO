#### **1. Сетевое взаимодействие — клиент-серверная архитектура, основные протоколы, их сходства и отличия. (网络交互 - 客户端-服务器架构，主要协议及其异同)**

**客户端-服务器架构**是一种分布式应用结构，将任务或工作负载划分为两个部分：

* **客户端 (Client):** 向服务器请求服务的程序或设备。例如：Web浏览器、手机App。
* **服务器 (Server):** 为客户端提供服务的程序或设备。例如：Web服务器、数据库服务器。

**主要协议：TCP 和 UDP**

| 特性               | TCP (传输控制协议)                                                                       | UDP (用户数据报协议)                                                    |
| :----------------- | :--------------------------------------------------------------------------------------- | :---------------------------------------------------------------------- |
| **连接**     | **面向连接的**。通信前需建立可靠连接（三次握手）。                                 | **无连接的**。直接发送数据，无需建立连接。                        |
| **可靠性**   | **高可靠性**。通过确认、重传、校验等机制确保数据无差错、不丢失、不重复且按序到达。 | **不可靠**。不保证数据送达，也不保证顺序。                        |
| **速度**     | 相对较慢。因为需要建立连接和保证可靠性。                                                 | 非常快。开销小，没有额外控制机制。                                      |
| **数据流**   | **字节流**。将数据视为无结构的字节流，没有消息边界。                               | **数据报**。发送的是有边界的数据包（数据报）。                    |
| **拥塞控制** | 有复杂的拥塞控制算法。                                                                   | 没有拥塞控制。                                                          |
| **应用场景** | 需要高可靠性的应用：Web（HTTP）、电子邮件（SMTP）、文件传输（FTP）。                     | 对速度敏感、能容忍少量丢失的应用：视频流、语音通话、在线游戏、DNS查询。 |

**相似点：** 两者都位于TCP/IP模型的传输层，都使用端口号来区分同一主机上的不同应用程序。

---

#### **2. Протокол TCP. Классы Socket и ServerSocket. (TCP协议。Socket 和 ServerSocket 类)**

在Java中，使用 `Socket` 和 `ServerSocket` 类来实现基于TCP的通信。

* **`ServerSocket` (服务器端):**

  * 用于在服务器上创建一个“监听端口”，等待客户端的连接请求。
  * 主要方法：`accept()`。这是一个**阻塞**方法，它会一直等待，直到有客户端连接上来，然后返回一个用于与该客户端通信的 `Socket` 对象。
* **`Socket` (客户端和服务器端):**

  * 客户端使用 `Socket(String host, int port)` 构造函数来连接到服务器。
  * 服务器端使用 `ServerSocket.accept()` 返回的 `Socket` 对象。
  * 通过 `Socket` 对象的 `getInputStream()` 和 `getOutputStream()` 方法获取输入/输出流，来进行数据的读写。

**工作流程：**

1. 服务器创建 `ServerSocket` 并调用 `accept()` 等待。
2. 客户端创建 `Socket`，指定服务器地址和端口，发起连接。
3. 服务器 `accept()` 方法返回一个与客户端对应的 `Socket`。
4. 双方通过各自的 `Socket` 获取输入输出流，进行通信。
5. 通信完成后，关闭流和Socket。

---

#### **3. Протокол UDP. Классы DatagramSocket и DatagramPacket. (UDP协议。DatagramSocket 和 DatagramPacket 类)**

Java使用 `DatagramSocket` 和 `DatagramPacket` 来实现基于UDP的通信。

* **`DatagramSocket`:** 表示用于发送和接收数据报包的Socket。类似于邮局或邮箱。
* **`DatagramPacket`:** 表示数据报包本身。类似于信件，包含了数据内容、目标地址（IP和端口）或源地址。

**工作流程：**

1. 发送方和接收方都创建一个 `DatagramSocket`（可以绑定到特定端口）。
2. 发送方创建一个 `DatagramPacket`，填入要发送的数据、数据长度、目标地址和端口。
3. 发送方调用 `DatagramSocket.send(packet)` 发送数据包。
4. 接收方创建一个空的 `DatagramPacket`（用于接收数据的缓冲区）。
5. 接收方调用 `DatagramSocket.receive(packet)` (**阻塞**方法) 等待数据包到来。
6. 数据包到达后，从 `DatagramPacket` 中解析出数据和发送方信息。

---

#### **4. Отличия блокирующего и неблокирующего ввода-вывода, их преимущества и недостатки. Работа с сетевыми каналами. (阻塞和非阻塞IO的区别、优缺点。网络通道的工作方式)**

|                    | **阻塞式IO (BIO)**                                                              | **非阻塞式IO (NIO)**                                                                                      |
| :----------------- | :------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------- |
| **工作方式** | 线程在执行IO操作（如 `read()`, `accept()`）时会被挂起，直到数据准备好或连接建立。 | 线程执行IO操作时立即返回一个状态。数据未准备好也不会阻塞线程。                                                  |
| **线程模型** | **一个连接一个线程**。需要为每个客户端连接分配一个单独的线程，资源消耗大。      | **少量线程处理大量连接**。使用一个或几个线程轮询多个通道（Channel），只有当通道真正有IO事件时才进行处理。 |
| **优点**     | 编程模型简单，易于理解。                                                              | 高并发、高性能，资源利用率高。                                                                                  |
| **缺点**     | 线程开销大，难以应对大量并发连接。                                                    | 编程模型复杂，需要理解Selector、Buffer、Channel等概念。                                                         |

**NIO的核心组件：**

* **Channel (通道):** 类似于流，但可以双向读写，并支持异步非阻塞操作。`SocketChannel`, `ServerSocketChannel`, `DatagramChannel`。
* **Buffer (缓冲区):** 一个容器对象，所有数据的读写都通过Buffer进行。
* **Selector (选择器):** 允许一个线程监控多个Channel的IO事件（如连接就绪、读就绪、写就绪）。

---

#### **5. Классы SocketChannel и DatagramChannel. (SocketChannel 和 DatagramChannel 类)**

这两个类是Java NIO中用于支持非阻塞IO的通道。

* **`SocketChannel`:** 用于TCP协议的非阻塞客户端Socket。可以替代 `Socket`。

  * 通过 `SocketChannel.open()` 创建。
  * 可以配置为非阻塞模式：`configureBlocking(false)`。
  * 连接到服务器：`connect(SocketAddress addr)`，在非阻塞模式下，此方法可能返回false，需要通过 `finishConnect()` 判断是否连接成功。
* **`ServerSocketChannel`:** 用于TCP协议的非阻塞服务器Socket。可以替代 `ServerSocket`。

  * 通过 `ServerSocketChannel.open()` 创建。
  * 同样可以设置为非阻塞模式。
  * 调用 `accept()` 在非阻塞模式下会立即返回，如果没有连接，则返回 `null`。
* **`DatagramChannel`:** 用于UDP协议的非阻塞Socket。可以替代 `DatagramSocket`。

  * 通过 `DatagramChannel.open()` 创建。
  * 可以像 `DatagramSocket` 一样发送和接收数据包，但支持非阻塞模式和使用Selector。

这些Channel都可以注册到 `Selector` 上，监听感兴趣的IO事件。

---

#### **6. Передача данных по сети. Сериализация объектов. (网络数据传输。对象序列化)**

在网络传输中，数据必须以字节流的形式发送。**序列化 (Serialization)** 是将Java对象的状态转换为字节流的过程，以便存储或传输。**反序列化 (Deserialization)** 则是将字节流转换回Java对象的过程。

---

#### **7. Интерфейс Serializable. Объектный граф, сериализация и десериализация полей и методов. (Serializable接口。对象图，字段和方法的序列化与反序列化)**

* **`Serializable` 接口:** 是一个标记接口（没有方法）。一个类只有实现了 `Serializable` 接口，它的对象才是可序列化的。
* **对象图 (Object Graph):** 当一个对象被序列化时，它所引用的所有其他对象也会被递归地序列化（这些对象也必须实现 `Serializable`）。整个关系网构成了一个对象图。
* **字段的序列化:**
  * 默认情况下，所有**非transient、非static**的字段都会被序列化。
  * 使用 `transient` 关键字修饰的字段不会被序列化（例如密码）。
  * `static` 字段属于类，不属于对象，因此不会被序列化。
* **方法:** 方法（代码本身）不会被序列化。序列化只关心对象的数据（状态）。反序列化时，JVM会使用当前类的定义来重建对象并恢复其数据。

---

#### **8. Java Stream API. Создание конвейеров. Промежуточные и терминальные операции. (Java Stream API。创建流水线。中间操作和终止操作)**

Java 8 Stream API 提供了一种高效处理数据集合（特别是集合类）的函数式编程方法。

* **流水线 (Pipeline):** 一系列对流数据的操作，通常包括：**数据源 -> (零个或多个中间操作) -> 一个终止操作**。
* **中间操作 (Intermediate Operations):** 如 `filter()`, `map()`, `sorted()`, `distinct()`。这些操作是“懒惰”的，它们返回一个新的Stream，不会立即执行，只是构建流水线。可以连接多个中间操作。
* **终止操作 (Terminal Operations):** 如 `forEach()`, `collect()`, `count()`, `reduce()`。这些操作会触发流水线的实际执行，执行后会产生一个结果或副作用，之后该Stream不能再被使用。

**示例：**

```java
List<String> names = Arrays.asList("Anna", "Bob", "Alice", "David", "Amy");
List<String> result = names.stream() // 创建流 (数据源)
        .filter(name -> name.startsWith("A")) // 中间操作 (过滤)
        .map(String::toUpperCase) // 中间操作 (映射/转换)
        .sorted() // 中间操作 (排序)
        .collect(Collectors.toList()); // 终止操作 (收集结果)
// result = ["ALICE", "AMY", "ANNA"]
```

---

#### **9. Шаблоны проектирования: ... (设计模式：...)**

以下是您列出的设计模式的简要说明：

1. **Decorator (装饰器):** 动态地给一个对象添加一些额外的职责。例如Java IO中的 `BufferedReader( new FileReader(...) )`。
2. **Iterator (迭代器):** 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示。例如Java集合的 `Iterator`。
3. **Factory Method (工厂方法):** 定义一个用于创建对象的接口，但让子类决定实例化哪一个类。将对象的创建与使用分离。
4. **Command (命令):** 将一个请求封装为一个对象，从而使您可以用不同的请求对客户进行参数化。用于实现撤销/重做、任务队列等。
5. **Flyweight (享元):** 运用共享技术有效地支持大量细粒度的对象。例如字符串常量池、包装类的缓存。
6. **Interpreter (解释器):** 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。（较少使用）
7. **Singleton (单例):** 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
8. **Strategy (策略):** 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。使得算法可独立于使用它的客户而变化。
9. **Adapter (适配器):** 将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
10. **Facade (外观):** 为子系统中的一组接口提供一个一致的界面，定义一个高层接口，使得这一子系统更加容易使用。
11. **Proxy (代理):** 为其他对象提供一种代理以控制对这个对象的访问。例如远程代理、虚拟代理、保护代理。

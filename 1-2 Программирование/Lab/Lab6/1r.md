#### **1. Сетевое взаимодействие — клиент-серверная архитектура, основные протоколы, их сходства и отличия.**

**Клиент-серверная архитектура** — это распределенная структура приложения, которая разделяет задачи между поставщиками услуг (серверами) и потребителями услуг (клиентами).

* **Клиент:** Программа или устройство, которое запрашивает услуги у сервера (например, веб-браузер).
* **Сервер:** Программа или устройство, которое предоставляет услуги клиентам (например, веб-сервер).

**Основные протоколы: TCP и UDP**

| Характеристика                          | TCP (Transmission Control Protocol)                                                                                                                                                                                                                                          | UDP (User Datagram Protocol)                                                                                                                                                                            |
| :---------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Соединение**                        | **Установление соединения** (connection-oriented). Перед обменом данными устанавливается надежное соединение (трехстороннее рукопожатие).                            | **Без установления соединения** (connectionless). Данные отправляются без предварительного соединения.                    |
| **Надежность**                        | **Высокая надежность.** Гарантирует доставку данных без ошибок, потерь, дублирования и в правильном порядке (подтверждения, повторная передача). | **Ненадежный.** Не гарантирует доставку, порядок или отсутствие дубликатов.                                                          |
| **Скорость**                            | Относительно медленнее из-за накладных расходов на установление соединения и обеспечение надежности.                                                                                 | Очень быстрый. Минимальные накладные расходы.                                                                                                                    |
| **Поток данных**                     | **Поток байтов** (byte stream). Данные не имеют границ сообщений.                                                                                                                                                               | **Дейтаграммы/Пакеты** (datagrams). Данные отправляются отдельными пакетами с четкими границами.                            |
| **Управление перегрузкой** | Имеет сложные алгоритмы управления перегрузкой сети.                                                                                                                                                                           | Отсутствует управление перегрузкой.                                                                                                                                     |
| **Использование**                  | Приложения, требующие надежности: HTTP, SMTP, FTP.                                                                                                                                                                                              | Приложения, чувствительные к задержкам, где допустима потеря части данных: видеостриминг, VoIP, онлайн-игры, DNS. |

**Сходства:** Оба работают на транспортном уровне модели TCP/IP и используют порты для идентификации приложений на хосте.

---

#### **2. Протокол TCP. Классы Socket и ServerSocket.**

В Java для TCP-коммуникации используются классы `Socket` и `ServerSocket`.

* **`ServerSocket` (на стороне сервера):**

  * Создает "порт прослушивания" на сервере, который ожидает запросы на подключение от клиентов.
  * Ключевой метод: `accept()`. Это **блокирующий** метод, который ожидает до тех пор, пока клиент не подключится, и затем возвращает объект `Socket` для общения с этим клиентом.
* **`Socket` (и на клиенте, и на сервере):**

  * Клиент использует конструктор `Socket(String host, int port)` для подключения к серверу.
  * Сервер использует `Socket`, возвращенный методом `ServerSocket.accept()`.
  * Через методы `getInputStream()` и `getOutputStream()` объекта `Socket` происходит чтение и запись данных.

**Рабочий процесс:**

1. Сервер создает `ServerSocket` и вызывает `accept()` для ожидания.
2. Клиент создает `Socket`, указывая адрес и порт сервера, инициируя соединение.
3. `accept()` на сервере возвращает `Socket` для клиента.
4. Обе стороны получают потоки ввода/вывода из своих `Socket` и общаются.
5. После общения потоки и сокеты закрываются.

---

#### **3. Протокол UDP. Классы DatagramSocket и DatagramPacket.**

Для работы с UDP в Java используются `DatagramSocket` и `DatagramPacket`.

* **`DatagramSocket`:** Представляет сокет для отправки и получения дейтаграмм. Аналогичен почтовому отделению.
* **`DatagramPacket`:** Представляет собой пакет данных (дейтаграмму). Аналогичен письму, содержащему данные, адрес назначения (IP и порт) или адрес отправителя.

**Рабочий процесс:**

1. Отправитель и получатель создают `DatagramSocket` (может быть привязан к конкретному порту).
2. Отправитель создает `DatagramPacket`, заполняя его данными, длиной, адресом и портом назначения.
3. Отправитель вызывает `DatagramSocket.send(packet)`.
4. Получатель создает пустой `DatagramPacket` (буфер для данных).
5. Получатель вызывает `DatagramSocket.receive(packet)` (**блокирующий** метод) для ожидания пакета.
6. Когда пакет прибывает, данные и информация об отправителе извлекаются из `DatagramPacket`.

---

#### **4. Отличия блокирующего и неблокирующего ввода-вывода, их преимущества и недостатки. Работа с сетевыми каналами.**

|                                       | **Блокирующий I/O (BIO)**                                                                                                                                                                                            | **Неблокирующий I/O (NIO)**                                                                                                                                                                                                                                                                               |
| :------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Как работает**     | Поток блокируется при выполнении операций I/O (например,`read()`, `accept()`) до тех пор, пока данные не будут готовы.                                | Поток выполняет операцию I/O и немедленно возвращает статус. Если данные не готовы, поток не блокируется.                                                                                                                               |
| **Модель потоков** | **Один поток на соединение.** Для каждого клиентского соединения требуется отдельный поток, что потребляет много ресурсов. | **Мало потоков на много соединений.** Один или несколько потоков опрашивают множество каналов (Channel) с помощью Selector, обрабатывая только те каналы, у которых есть события I/O. |
| **Плюсы**                  | Простая модель программирования, легкая для понимания.                                                                                                                                 | Высокая производительность и масштабируемость при большом количестве соединений, эффективное использование ресурсов.                                                                                                 |
| **Минусы**                | Высокие накладные расходы на потоки, плохая производительность при высокой одновременной нагрузке.                                              | Более сложная модель программирования (Selector, Buffer, Channel).                                                                                                                                                                                                                         |

**Основные компоненты NIO:**

* **Channel (Канал):** Похож на Stream, но может читать и писать, поддерживает неблокирующий режим. `SocketChannel`, `ServerSocketChannel`, `DatagramChannel`.
* **Buffer (Буфер):** Контейнер для данных. Все операции чтения/записи происходят через буфер.
* **Selector (Селектор):** Позволяет одному потоку мониторить множество каналов на предмет событий I/O (connect, read, write).

---

#### **5. Классы SocketChannel и DatagramChannel.**

Это классы из Java NIO для неблокирующего I/O.

* **`SocketChannel`:** Неблокирующий клиентский TCP-сокет. Замена для `Socket`.

  * Создается через `SocketChannel.open()`.
  * Настраивается в неблокирующий режим: `configureBlocking(false)`.
  * Подключение: `connect(SocketAddress addr)`. В неблокирующем режиме может вернуть `false`, необходимо проверять завершение подключения через `finishConnect()`.
* **`ServerSocketChannel`:** Неблокирующий серверный TCP-сокет. Замена для `ServerSocket`.

  * Создается через `ServerSocketChannel.open()`.
  * Также настраивается в неблокирующий режим.
  * `accept()` в неблокирующем режиме немедленно возвращает `null`, если подключений нет.
* **`DatagramChannel`:** Неблокирующий UDP-сокет. Замена для `DatagramSocket`.

  * Создается через `DatagramChannel.open()`.
  * Может отправлять/получать данные как `DatagramSocket`, но поддерживает неблокирующий режим и использование Selector.

Эти каналы могут быть зарегистрированы в `Selector` для отслеживания событий I/O.

---

#### **6. Передача данных по сети. Сериализация объектов.**

При передаче данных по сети информация должна быть представлена в виде байтового потока. **Сериализация (Serialization)** — это процесс преобразования состояния Java-объекта в байтовый поток для сохранения или передачи. **Десериализация (Deserialization)** — это обратный процесс восстановления объекта из байтового потока.

---

#### **7. Интерфейс Serializable. Объектный граф, сериализация и десериализация полей и методов.**

* **Интерфейс `Serializable`:** Маркерный интерфейс (не имеет методов). Класс должен реализовать этот интерфейс, чтобы его объекты можно было сериализовать.
* **Объектный граф (Object Graph):** При сериализации объекта рекурсивно сериализуются все объекты, на которые он ссылается (они тоже должны быть `Serializable`). Эта сеть связей образует объектный граф.
* **Сериализация полей:**
  * По умолчанию сериализуются все **нетранзитные (non-transient) и нестатические (non-static)** поля.
  * Поле, помеченное ключевым словом `transient`, **не** сериализуется (например, пароль).
  * `static`-поля принадлежат классу, а не объекту, и поэтому не сериализуются.
* **Методы:** Методы (код) не сериализуются. Сериализуется только состояние объекта (данные). При десериализации JVM использует текущее определение класса для создания объекта и восстановления его данных.

---

#### **8. Java Stream API. Создание конвейеров. Промежуточные и терминальные операции.**

Java Stream API предоставляет функциональный подход к эффективной обработке данных, особенно коллекций.

* **Конвейер (Pipeline):** Последовательность операций над потоком данных. Обычно включает: **Источник -> (0+ промежуточных операций) -> Терминальная операция**.
* **Промежуточные операции (Intermediate Operations):** Например, `filter()`, `map()`, `sorted()`, `distinct()`. Они "ленивые" (lazy), возвращают новый Stream и не выполняются немедленно, а лишь формируют конвейер. Можно соединять в цепочку.
* **Терминальные операции (Terminal Operations):** Например, `forEach()`, `collect()`, `count()`, `reduce()`. Запускают выполнение всего конвейера. После выполнения дают результат или побочный эффект. Поток после этого нельзя использовать.

**Пример:**

```java
List<String> names = Arrays.asList("Anna", "Bob", "Alice", "David", "Amy");
List<String> result = names.stream() // Источник
        .filter(name -> name.startsWith("A")) // Промежуточная (фильтр)
        .map(String::toUpperCase) // Промежуточная (преобразование)
        .sorted() // Промежуточная (сортировка)
        .collect(Collectors.toList()); // Терминальная (сбор в список)
// result = ["ALICE", "AMY", "ANNA"]
```

---

#### **9. Шаблоны проектирования: ...**

1. **Decorator (Декоратор):** Динамически добавляет объекту новые обязанности. Например, `BufferedReader( new FileReader(...) )` в Java IO.
2. **Iterator (Итератор):** Предоставляет способ последовательного доступа к элементам составного объекта, не раскрывая его внутреннего представления. Например, `Iterator` в Java Collections.
3. **Factory Method (Фабричный метод):** Определяет интерфейс для создания объекта, но позволяет подклассам решать, какой класс инстанцировать. Отделяет создание от использования.
4. **Command (Команда):** Инкапсулирует запрос в виде объекта, что позволяет параметризовать клиенты различными запросами, организовывать очередь запросов, поддерживать отмену операций.
5. **Flyweight (Приспособленец):** Использует разделение для эффективной поддержки множества мелких объектов. Например, пул строк, кэш в классах-обертках (Integer).
6. **Interpreter (Интерпретатор):** Определяет представление грамматики и интерпретатор для заданного языка. (Используется редко).
7. **Singleton (Одиночка):** Гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к нему.
8. **Strategy (Стратегия):** Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.
9. **Adapter (Адаптер):** Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом. Позволяет совместно работать классам с несовместимыми интерфейсами.
10. **Facade (Фасад):** Предоставляет унифицированный интерфейс к набору интерфейсов в подсистеме. Определяет интерфейс более высокого уровня, который упрощает использование подсистемы.
11. **Proxy (Заместитель):** Предоставляет объект-заместитель, который контролирует доступ к другому объекту. Например, удаленный прокси, виртуальный прокси, защитный прокси.

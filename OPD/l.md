第四次实验答辩的问题

理论部分

1. 什么是子程序？为什么需要子程序？其优点是什么？使用子程序能带来哪些收益？
2. 子程序参数传递方式（根据讲义内容说明）
   - 通过AC来传递（只能传递一个），用A0XX将参数直接传入AC中，再直接调用子程序直接开始子程序指定的行为
   - 通过内存单元的地址传递 1将栈顶内容传递进AC 2再将其写入指定内存（示例为042）3将042内容加1并写入AC（相当于栈顶内容加1） 4将加1后的栈顶内容存入043
   - 通过栈传递（可以传递多个参数），可以用A0XX将参数传入AC再用0C00 PUSH进栈，多次重复操作传递多个值,在子程序中可以使用ACXX获得栈中的元素
3. 什么是栈？在BÉVM计算机中栈位于何处？
   - 栈（Stack）通常是在程序的内存中分配的一块区域，用于存储局部变量、函数参数和返回地址。栈位于内存的高地址部分，并向低地址方向增长。
4. 栈操作指令（PUSH和POP）
5. 是否可以使用其他指令操作栈？与PUSH/POP有什么区别？
6. 为什么在子程序内部不使用PUSH和POP？为什么在主程序中使用这些指令？
   - 调用子程序时，CALL 指令会自动将返回地址压入栈，而 RET 指令会从栈中弹出返回地址。若子程序内部随意使用 PUSH/POP，可能破坏栈指针（SP）的位置，导致无法正确找到返回地址，从而引发程序崩溃或跳转到错误地址。
   - При вызове подпрограммы инструкция CALL автоматически помещает адрес возврата в стек, а инструкция RET извлекает адрес возврата из стека. Если внутри подпрограммы произвольно использовать PUSH/POP, это может нарушить положение указателя стека (SP), что приведёт к невозможности корректного определения адреса возврата. В результате это может вызвать аварийное завершение программы или переход по неверному адресу.
7. BÉVM计算机是否支持递归？递归深度受什么限制？
   - Рекурсивность - способность подпрограммы вызывать саму себя. 
   - 递归的深度受制于指令中偏移值的比特的位数
8. 什么是可重入性？你的程序是否具有可重入性？为什么？
9. 

实践部分

1. 请分时钟周期讲解指令执行过程/计算内存访问次数/给出指令执行后寄存器内容：
010  DA12

2. 当SP=7FE时，执行以下指令后将调用哪个地址的子程序：
010  DC01

3. 根据给定的初始栈状态，绘制执行RET/PUSH/POP/CALL指令后的栈状态

4. 使用栈相对寻址的LD/ST指令会如何改变栈状态？

5. 当SP=7FE时，以下指令将跳转到哪个地址：
7FD  CCFF

6. RET指令是否可以用其他指令组合替代（如果可以）？
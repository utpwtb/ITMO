### 1. **Коллекции и сортировка: `Comparable` и `Comparator`**

**Коллекции (Collections)**

- **Определение**: Контейнеры для хранения и управления группами объектов (например, `List`, `Set`, `Queue`).
- **Сортировка**:
  - **Интерфейс `Comparable`**
    - **Назначение**: Определяет «естественный порядок» объектов (например, `String` по алфавиту, `Integer` по возрастанию).
    - **Реализация**: Класс должен имплементировать метод `compareTo(T o)`.

    ```java
    class Student implements Comparable<Student> {
        int age;
        public int compareTo(Student s) {
            return this.age - s.age; // Сортировка по возрасту (возрастание)
        }
    }
    ```
  - **Интерфейс `Comparator`**
    - **Назначение**: Создание пользовательских правил сортировки (например, по имени студента).
    - **Реализация**: Отдельный класс-компаратор или лямбда-выражения.

    ```java
    Comparator<Student> nameComparator = (s1, s2) -> s1.getName().compareTo(s2.getName());
    Collections.sort(students, nameComparator); // Сортировка по имени
    ```
  - **Сравнение**:  | **`Comparable`**                     | **`Comparator`**                         |
    | -------------------------------------------- | ------------------------------------------------ |
    | Изменяет сам класс           | Внешняя логика сортировки |
    | Одно правило сортировки | Множество правил                  |

---

### 2. **Категории коллекций: списки, множества, `Map`**

- **Списки (List)**
  - **Особенности**: Упорядоченные, допускают дубликаты, доступ по индексу.
  - **Реализации**:
    - `ArrayList`: Динамический массив, быстрый доступ, медленные вставка/удаление.
    - `LinkedList`: Связный список, быстрые вставка/удаление, медленный доступ.
- **Множества (Set)**
  - **Особенности**: Уникальные элементы, неупорядоченные (`HashSet`) или упорядоченные (`TreeSet`).
  - **Реализации**:
    - `HashSet`: Хэш-таблица, поиск за O(1).
    - `TreeSet`: Красно-черное дерево, сортировка по естественному порядку.
- **Map**
  - **Особенности**: Хранит пары «ключ-значение», ключи уникальны.
  - **Реализации**:
    - `HashMap`: Хэш-таблица, допускает `null`.
    - `TreeMap`: Сортировка ключей по естественному порядку.

---

### 3. **Generics и Wildcard-параметры**

- **Generics**
  - **Цель**: Обеспечение типобезопасности, предотвращение `ClassCastException`.
  - **Пример**:
    ```java
    class Box<T> {
        private T content;
        public void setContent(T content) { this.content = content; }
    }
    Box<String> box = new Box<>(); // Может хранить только String
    ```
- **Wildcard**
  - **`<?>`**: Любой тип (например, `List<?>` принимает список любого типа).
  - **`<? extends T>`**: Верхняя граница (только чтение, нельзя добавлять элементы).
  - **`<? super T>`**: Нижняя граница (можно добавлять элементы типа `T`, например, `List<? super Integer>`).

---

### 4. **Классы-оболочки и автоупаковка/распаковка**

- **Классы-оболочки**
  - **Назначение**: Преобразование примитивов в объекты (например, `int` → `Integer`).
  - **Недостатки**:
    - **Память**: Объекты занимают больше места.
    - **Производительность**: Автоупаковка/распаковка в циклах замедляет код.
- **Автоупаковка/распаковка**
  ```java
  Integer i = 10;      // Автоупаковка: int → Integer
  int j = i;           // Автораспаковка: Integer → int
  List<Integer> list = new ArrayList<>();
  list.add(5);         // Автоупаковка
  ```

---

### 5. **Потоки ввода-вывода: байтовые, символьные, цепочки**

- **Байтовые потоки**
  - **Базовые классы**: `InputStream` (например, `FileInputStream`), `OutputStream`.
  - **Использование**: Работа с бинарными данными (изображения, видео).
- **Символьные потоки**
  - **Базовые классы**: `Reader` (например, `FileReader`), `Writer`.
  - **Использование**: Текстовые файлы (автоматическая обработка кодировок).
- **Цепочки потоков**
  - **Цель**: Комбинирование потоков для сложных операций (буферизация, сжатие).

  ```java
  // Чтение файла с буферизацией
  try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
      String line = br.readLine();
  }
  ```

---

### 6. **Работа с файлами: `java.io.File`**

- **Функции**:
  - Создание/удаление: `createNewFile()`, `mkdir()`.
  - Проверка свойств: `exists()`, `isFile()`, `isDirectory()`.
- **Ограничения**:
  - Нет поддержки атомарных операций или блокировок (используйте `java.nio.file.Files`).

---

### 7. **Пакет `java.nio`**

- **Основные возможности**:
  - **Неблокирующий I/O**: Высокая производительность через `Selector` и `Channel`.
  - **Memory-mapped файлы**: Эффективная работа с большими файлами (`FileChannel.map()`).
- **Ключевые классы**:
  - `Path`: Абстракция пути к файлу (например, `Paths.get("data.txt")`).
  - `Files`: Утилиты для операций с файлами (`copy()`, `readAllLines()`).

---

### 8. **Утилита `javadoc`**

- **Шаги использования**:
  1. Добавьте комментарии в код:
     ```java
     /**
      * Суммирует два числа
      * @param a первое число
      * @param b второе число
      * @return сумма a и b
      */
     public int add(int a, int b) { return a + b; }
     ```
  2. Генерация документации: `javadoc -d doc MyClass.java`.
- **Особенности**:
  - Поддержка HTML-ссылок и вставки кода (`{@code ...}`).
  - Интеграция с IDE (например, подсказки в IntelliJ).

---

**Примечание**: Технические термины (например, `ArrayList`, `Generics`) сохранены на английском в соответствии с общепринятой практикой.

---

以下是针对每个问题的详细解释，涵盖核心概念、使用场景、代码示例及注意事项：

---

### 1. **集合与排序：`Comparable` 和 `Comparator`**

**集合 (Collections)**

- **定义**：用于存储和管理一组对象的容器（如 `List`, `Set`, `Queue`）。
- **排序方式**：
  - **`Comparable` 接口**
    - **用途**：定义对象的“自然排序规则”（如 `String` 按字母排序，`Integer` 按数值排序）。
    - **实现**：类需实现 `compareTo(T o)` 方法。

    ```java
    class Student implements Comparable<Student> {
        int age;
        public int compareTo(Student s) {
            return this.age - s.age; // 按年龄升序
        }
    }
    ```
  - **`Comparator` 接口**
    - **用途**：定义“自定义排序规则”（如按学生姓名排序）。
    - **实现**：创建独立比较器类或使用 Lambda 表达式。

    ```java
    Comparator<Student> nameComparator = (s1, s2) -> s1.getName().compareTo(s2.getName());
    Collections.sort(students, nameComparator); // 按姓名排序
    ```
  - **对比**：  | **`Comparable`** | **`Comparator`** |
    | ------------------------ | ------------------------ |
    | 修改类自身               | 不修改类，外部定义       |
    | 单一排序规则             | 支持多种排序规则         |

---

### 2. **集合类别：列表、集合、`Map`**

- **列表 (List)**
  - **特点**：有序、允许重复，支持索引访问。
  - **实现类**：
    - `ArrayList`：基于动态数组，随机访问快，增删慢。
    - `LinkedList`：基于链表，增删快，随机访问慢。
- **集合 (Set)**
  - **特点**：元素唯一，无序（`HashSet`）或有序（`TreeSet`）。
  - **实现类**：
    - `HashSet`：基于哈希表，查找 O(1)。
    - `TreeSet`：基于红黑树，元素按自然顺序排序。
- **Map**
  - **特点**：键值对存储，键唯一。
  - **实现类**：
    - `HashMap`：哈希表实现，允许 `null` 键/值。
    - `TreeMap`：按键自然顺序排序。

---

### 3. **泛型与通配符**

- **泛型 (Generics)**
  - **作用**：类型安全，避免运行时 `ClassCastException`。
  - **示例**：
    ```java
    class Box<T> {
        private T content;
        public void setContent(T content) { this.content = content; }
    }
    Box<String> box = new Box<>(); // 只能存储 String
    ```
- **通配符 (Wildcard)**
  - **`<?>`**：未知类型（如 `List<?>` 可接受任何类型的列表）。
  - **`<? extends T>`**：上界通配符（只读，不能添加元素）。
  - **`<? super T>`**：下界通配符（可写入，如向 `List<? super Integer>` 添加 `Integer`）。

---

### 4. **包装类与自动装箱/拆箱**

- **包装类 (Wrapper Classes)**
  - **用途**：将基本类型（如 `int`）转为对象（`Integer`），用于泛型集合（如 `List<Integer>`）。
  - **缺点**：
    - **内存开销**：对象占用更多内存（如 `Integer` vs `int`）。
    - **性能损耗**：频繁装箱/拆箱影响性能（尤其在循环中）。
- **自动装箱/拆箱**
  ```java
  Integer i = 10;      // 自动装箱：int → Integer
  int j = i;           // 自动拆箱：Integer → int
  List<Integer> list = new ArrayList<>();
  list.add(5);         // 自动装箱
  ```

---

### 5. **I/O 流：字节流、字符流与流链**

- **字节流**
  - **父类**：`InputStream`（如 `FileInputStream`）、`OutputStream`。
  - **适用场景**：处理二进制文件（如图片、视频）。
- **字符流**
  - **父类**：`Reader`（如 `FileReader`）、`Writer`。
  - **适用场景**：处理文本文件（自动处理字符编码）。
- **流链 (Stream Chaining)**
  - **目的**：通过组合流实现复杂处理（如缓冲、解压缩）。

  ```java
  // 读取文件并缓冲，避免频繁磁盘访问
  try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
      String line = br.readLine();
  }
  ```

---

### 6. **文件操作：`java.io.File`**

- **功能**：
  - 创建/删除文件或目录：`createNewFile()`, `mkdir()`。
  - 检查属性：`exists()`, `isFile()`, `isDirectory()`。
- **局限性**：
  - 不支持原子操作或文件锁（需用 `java.nio.file.Files`）。

---

### 7. **`java.nio` 包**

- **核心特性**：
  - **非阻塞 I/O**：通过 `Selector` 和 `Channel` 实现高并发。
  - **内存映射文件**：通过 `FileChannel.map()` 高效读写大文件。
- **关键类**：
  - `Path`：替代 `File`，支持路径操作（如 `Paths.get("data.txt")`）。
  - `Files`：提供静态方法（如 `copy()`, `readAllLines()`）。

---

### 8. **Javadoc 工具**

- **使用步骤**：
  1. 在代码中添加文档注释：
     ```java
     /**
      * 计算两数之和
      * @param a 第一个加数
      * @param b 第二个加数
      * @return 两数之和
      */
     public int add(int a, int b) { return a + b; }
     ```
  2. 命令行生成文档：`javadoc -d doc MyClass.java`。
- **特点**：
  - 支持 HTML 超链接和代码片段（`{@code ...}`）。
  - IDE 集成（如 IntelliJ 自动提示文档）。

---

以上内容在保留术语英文形式的前提下，结合代码示例和对比分析，提供了更深入的技术细节。
